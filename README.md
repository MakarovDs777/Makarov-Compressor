[![animation.gif](https://i.postimg.cc/0yFdyz5t/animation.gif)](https://postimg.cc/K17g9vML)
# Концепция компрессора Макарова
Не имеет значения то что мы считаем, а имеет значение то как мы это считаем, и для того что-бы сжимать, и разжимать данные мне не нужно их ни сжимать, ни разжимать мне достаточно просто сгенерировать файлы ведь любую информацию я могу превратить в последовательность чисел, и эту последовательнсоть чисел я могу превратить обратно в ту же самую информацию. Поначалу у меня была идея написать функцию f(x) с двумя волнистыми немого погодя я поискал в сети и нашел в сети такое определнние как интерполяционный многочлен Лагранжа, но немного погодя я понял что это бессмысленная затея, и я начал искать дальше и нашел такую штуку как Архимедовые спирали, хотя в принципе я подумал спирали Архимеда то даже и не нужны. Достаточно просто иметь отрезок N длины, и кривую тупо запульнуть на полярной системы координат и при каждой последующей итерации она будет на какое-то число градусов тета отклоняться типа массив и там есть значения отклонений при каждой последующей итерации расстояния кривой на которую она отклоняется [20%, -5%, etc...] на какое-то значение таким образом попадая на отрезке в нужные числа массива. И когда она заканчивается она начинается считать с начала массива, и всё вообще можно не париться в принципе... Самого количества чисел отклонений тета не так много нужно что-бы выстроить нужную траекторию. А подумал и понял что в принципе можно вторую кривую такую же сделать и просто запереть её в какую нибудь геометрическую фигуру типа круга, или другой геометрической фигурой, и даже просто менять эту геометрическую фигуру при каждой последующей итерации, и разделить эту геометрическую фигуру на отрезки значений градусов тета, и когда она будет попадать на отрезки круга то будет вносить значение этого отрезка градуса тета в отклонение итерации первой кривой, и рикошетить к следующей нужной итерации для отклонения на то количество градусов для которого нужно попасть первой кривой на отрезок что-бы выдать нужное следующие число в массиве N чисел. Или как вариант можно это делать в трехмерном пространстве создать 3-x мерную фигуру разделив её на отрезки значений, выстрелить пулей, и заставить фигуру вращаться с какой нибудь скорость типа постоянной или переменной по какой нибудь траектории типа вперед~назад, влево~вправо, и сопоставив скорость~траекторию движения пули изначально, скорость~траекторию~движение фигуры, и градус рикошета пули при столкновении можно вычислить в какие отрезки фигуры она попадет, и найти нужные неизвестные переменные которые выдадут любые нужные числа. Чем тоже не вариант!? Вообщем есть к чему стремиться...

# Makarov-Compressor
Основная идея программы заключается в использовании библиотеки matplotlib для визуализации геометрической фигуры на полярных координатах. В первой функции create_geometric_shape создается фигура на основе переданного массива чисел, разделенная на отрезки с помощью функции plot. Затем она возвращает радиус r, угол theta и переменную fig, представляющую собой созданную геометрическую фигуру.

Во второй функции get_numbers_from_geometric_shape мы получаем объекты линий из созданной фигуры, получаем метки (номера) каждой линии, и возвращаем массив чисел. Эта функция принимает радиус r, угол theta и переменную fig, возвращаемую из первой функции.

В приведенном примере массив чисел [2, 4, 3, 1, 5] подается на вход первой функции, строится геометрическая фигура и сохраняется радиус r, угол theta и переменная fig. Затем вызывается вторая функция, которая извлекает массив чисел из геометрической фигуры. Полученный результат [2, 4, 3, 1, 5] выводится на экран.

# CodePen
Данный код разделяет текст на массив символов, и массив с массивами всех индексов всех символов массива, и превратив это в единый массив по нему создать обратно массив с массивами по которому обратно создать тот самый текст обратно. 
